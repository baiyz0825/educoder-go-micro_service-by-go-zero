[TOC]---### 任务描述本节任务我们将着重了解，GORM这一个ORM框架，学习基本使用Gorm-gen快速生成数据库查询的基本桩代码，并学习，如何使用Gorm-Gen进行查询数据库数据。### 相关知识1. [mysql的基本语法](https://www.runoob.com/mysql/mysql-tutorial.html)2. [GORM-Gen](https://gorm.io/zh_CN/gen/)#### Gorm-Gen 基本介绍与大部分的Orm框架，类似，都提供了声明式的API查询方法，提供从数据DAO模型到业务模型的转化，提供对应动态Sql的生成。其基本功能包括：(摘录自[官方文档](https://gorm.io/zh_CN/gen/))- Idiomatic & Reusable API from Dynamic Raw SQL- 100% Type-safe DAO API without interface{}- Database To Struct follows GORM conventions- GORM under the hood, supports all features, plugins, DBMS that GORM supports这里的Gorm-Gen是针对Gorm对于复杂场景下的Sql查询拼装做了定制优化，Gorm提供的基本功能如下- 全功能 ORM- 关联 (Has One，Has Many，Belongs To，Many To Many，多态，单表继承)- Create，Save，Update，Delete，Find 中钩子方法- 支持 Preload、Joins 的预加载- 事务，嵌套事务，Save Point，Rollback To Saved Point- Context、预编译模式、DryRun 模式- 批量插入，FindInBatches，Find/Create with Map，使用 SQL 表达式、Context Valuer 进行 CRUD- SQL 构建器，Upsert，数据库锁，Optimizer/Index/Comment Hint，命名参数，子查询- 复合主键，索引，约束- Auto Migration- 自定义 Logger- 灵活的可扩展插件 API：Database Resolver（多数据库，读写分离）、Prometheus…- 每个特性都经过了测试的重重考验- 开发者友好##### 代码生成下面我们来介绍如何使用Gorm-Gen中代码生成，来帮助生成对应的桩代码程序：> 在Gorm-Gen中，我们生成基本的持久层方法有两种- 可以使用定义好的Dao结构，生成对应的Sql语句- 通过从数据库中获取表结构进行逆向生成###### DAO -> 查询桩代码> 注意： 在编写生成文件之前，请先创建go.mod模块1. 声明基本的业务结构，下面我们声明一个`User`的业务结构，主要包含UserName,Passwd两个字段，数据库列与类型，使用gorm Tag进行标注```gopackage modelimport (	"gorm.io/gorm")type User struct {	gorm.Model        // 传入Gorm相关属性	ID         uint   `gorm:"primary_key"`	UserName   string `gorm:"column:name"`	Passwd     string `gorm:"column:password"`}```2. 下面我们来介绍如何自定义Sql生成相对应的查询语句> 此部分摘录自：[稀土掘金：ag9920](https://juejin.cn/post/7133150674400837668)基本语法：- gen.T 用于返回数据的结构体，会根据生成结构体或者数据库表结构自动生成- gen.M 表示map[string]interface{},用于返回数据- gen.RowsAffected 用于执行SQL进行更新或删除时候,用于返回影响行数- @@table 查询的表名，如果没有传参，会根据结构体或者表名自动生成- @@<name> 当表名或者字段名可控时候，用@@占位，name为可变参数名，需要函数传入。- @<name> 当数据可控时候，用@占位，name为可变参数名，需要函数传入- 出于安全拼接考虑，like查询不支持在SQL中拼接%，如需要拼接，需要在调用函数参数中拼接好。- 逻辑操作必须包裹在{{}}中，如{{if}},结束语句必须是 {{end}}, 所有的语句都可以嵌套。{{}}中的语法除了{{end}}其它的都是Golang语法；- {{if}} 支持通过满足条件拼接字符串到SQL；- where 只有在where子句不为空时候插入where，若子句的开头为 where连接关键字AND 或 OR，会将它们去除。- set 只有在set子句不为空时候插入set，若子句的开头为,会将它们去除。- for 通过遍历数组并将其内容插入到SQL中,需要注意之前的连接词。- 所有子句需要用{{end}} 结束子句，支持嵌套使用示例:```gopackage modelimport (	"gorm.io/gen")// only used to Usertype UserMethod interface {	// where(id=@id)	FindByID(id int64) (gen.T, error)	// select * from @@table where name=@userName	FindByUserName(userName string) ([]gen.T, error)	// update users	//	{{set}}	//		{{if passwd != ""}}	//			password=@passwd	//		{{end}}	//	{{end}}	// where id=@id	UpdateUserName(passwd string, id int) error}```3. 使用生成器，生成对应的查询代码```gopackage genimport (	"gorm.io/gen"	"model/model")func GenCode() {	// 声明一个生成器	g := gen.NewGenerator(gen.Config{		// 生成器输出目录		OutPath: "./query",		Mode:    gen.WithDefaultQuery,	})	// 生成Gorm自带的基本查询结构	g.ApplyBasic(model.User{})	// 提交需要生成的基本自定义接口	g.ApplyInterface(func(model.UserMethod) {}, model.User{})	// 执行生成器	g.Execute()}```4. 编写主程序```gopackage mainimport (	"model/gen")func main() {	// 调用生成器	gen.GenCode()}```5. 生成之后的代码结构```text.├── gen│   └── generator.go // 代码生成器├── go.mod├── go.sum├── main.go // 主程序├── model│   ├── user.go // 自定义指定的User结构│   └── usermethod.go // 指定的自定义动态sql方法└── query    ├── gen.go // 生成的gen查询结构    └── users.gen.go // 生成的数据库映射对象```6. 链接数据库执行基本Sql> 下面重新编写main方法，修改方法调用```goimport (	"context"	"fmt"	"gorm.io/driver/mysql"	"gorm.io/gorm"	"model/query")func main() {	// 调用生成器	// gen.GenCode()	// Initialize a *gorm.DB instance	db, _ := gorm.Open(mysql.Open("root:@(127.0.0.1:3306)/user_test?charset=utf8mb4&parseTime=True&loc=Local"))	// 注入db到查询器中	query.SetDefault(db)	user, err := query.User.WithContext(context.Background()).FindByUserName("bigWhite")	if err != nil {		fmt.Printf("error is :%v", err)		return	}	fmt.Printf("user is :%v", user)	return}```###### DB -> 查询桩代码在这里我们介绍如何使用数据库逆向生成对应的桩代码:```gopackage genimport (	"fmt"	"gorm.io/driver/mysql"	"gorm.io/gen"	"gorm.io/gorm")// UserQuerier 生成的自定义动态sqltype UserQuerier interface {	// GetByIdOrUniqueId  使用ID || uuid 查找用户	//	// SELECT * FROM @@table	//  {{WHERE}}	//      {{if uid != -1 }}	//          uid = @id	//      {{else if uuid != -1}}	//          unique_id = @uuid	//      {{end}}	//  {{end}}	GetByIdOrUniqueId(uid int64, uuid int64) ([]gen.T, error)	// GetUserByPhoneNumber 使用手机号查找用户	//	// SELECT * FROM @@table WHERE phone = @phone	GetUserByPhoneNumber(phone string) ([]gen.T, error)	// Update 可选更新用户属性	//	// UPDATE @@table	//  {{set}}	//    {{if user.Name != ""}} username=@user.Name, {{end}}	//    {{if user.Age > 0}} age=@user.Age, {{end}}	//    {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}	//  {{end}}	// WHERE id = @id	Update(user gen.T, id int64) (gen.RowsAffected, error)}// GenModel 生成用户模块持久层数据func GenModel() {	const MysqlConfig = "username:passwd@tcp(host:port)/table_name?charset=utf8mb4&parseTime=True&loc=Local"	// 连接数据库	db, err := gorm.Open(mysql.Open(MysqlConfig))	if err != nil {		panic(fmt.Errorf("cannot establish db connection: %w", err))	}	// 自定义模型结体字段的标签	// 将特定字段名的 json 标签加上`string`属性,即 MarshalJSON 时该字段由数字类型转成字符串类型	// jsonField := gen.FieldJSONTagWithNS(func(columnName string) (tagContent string) {	// 	return strings.TrimPrefix(columnName, "u_")	// })	// 将非默认字段名的字段定义为自动时间戳和软删除字段;	// 自动时间戳默认字段名为:`updated_at`、`created_at, 表字段数据类型为: INT 或 DATETIME	// 软删除默认字段名为:`deleted_at`, 表字段数据类型为: DATETIME	// 创建更新时间，需要自己进行指定类型，并且数据库中delete_time，update_time均无需设置默认值	autoUpdateTimeField := gen.FieldGORMTag("update_time", "column:update_time;type:int unsigned;autoUpdateTime")	autoCreateTimeField := gen.FieldGORMTag("create_time", "column:create_time;type:int unsigned;autoCreateTime")	softDeleteField := gen.FieldType("delete_time", "gorm.DeletedAt")	// 是否去除字段前缀	// fieldTrimPrefix := gen.FieldTrimPrefix("u_")	// 模型自定义选项组	// fieldOpts := []gen.ModelOpt{jsonField, autoCreateTimeField, autoUpdateTimeField, softDeleteField, fieldTrimPrefix}	fieldOpts := []gen.ModelOpt{autoCreateTimeField, autoUpdateTimeField, softDeleteField}	// 自定义字段的数据类型	// 统一数字类型为int64,兼容protobuf	dataMap := map[string]func(detailType string) (dataType string){		"tinyint":   func(detailType string) (dataType string) { return "int64" },		"smallint":  func(detailType string) (dataType string) { return "int64" },		"mediumint": func(detailType string) (dataType string) { return "int64" },		"bigint":    func(detailType string) (dataType string) { return "int64" },		"int":       func(detailType string) (dataType string) { return "int64" },	}	// 生成实例	conf := &gen.Config{		// 生成query全局查询对象时候，需要区分Model path 和输出path Q会默认使用OutPath最后一个路径当包名称，如果不修改modelPKg会导致生成文件中导入结构体错误		OutPath: "./query",		// 生成全局查询文件名称		OutFile:      "query.go",		ModelPkgPath: "model",		// WithDefaultQuery 生成默认查询结构体(作为全局变量使用), 即`Q`结构体和其字段(各表模型)		// WithoutContext 生成没有context调用限制的代码供查询		// WithQueryInterface 生成interface形式的查询代码(可导出), 如`Where()`方法返回的就是一个可导出的接口类型		Mode: gen.WithDefaultQuery | gen.WithQueryInterface,		// 表字段可为 null 值时, 对应结体字段使用指针类型		FieldNullable: true, // generate pointer when field is nullable		// 表字段默认值与模型结构体字段零值不一致的字段, 在插入数据时需要赋值该字段值为零值的, 结构体字段须是指针类型才能成功, 即`FieldCoverable:true`配置下生成的结构体字段.		// 因为在插入时遇到字段为零值的会被GORM赋予默认值. 如字段`age`表默认值为10, 即使你显式设置为0最后也会被GORM设为10提交.		// 如果该字段没有上面提到的插入时赋零值的特殊需要, 则字段为非指针类型使用起来会比较方便.		FieldCoverable: true, // generate pointer when field has default value, to fix problem zero value cannot be assign: https://gorm.io/docs/create.html#Default-Value		// 模型结构体字段的数字类型的符号表示是否与表字段的一致, `false`指示都用有符号类型		FieldSignable: false, // detect integer field's unsigned type, adjust generated data type		// 生成 gorm 标签的字段索引属性		FieldWithIndexTag: false, // generate with gorm index tag		// 生成 gorm 标签的字段类型属性		FieldWithTypeTag: false, // generate with gorm column type tag:		// 生成单元测试		WithUnitTest: true,	}	conf.WithDataTypeMap(dataMap)	conf.WithOpts(fieldOpts...)	g := gen.NewGenerator(*conf)	// 设置目标 db	g.UseDB(db)	// 创建模型的结构体 表名称 和 实体名称	User := g.GenerateModelAs("user", "User")	// 提交需要产生的数据库模型结构	g.ApplyBasic(User)	// 执行生成代码	g.Execute()}```> 上面介绍了基本的GORM-GEN的使用方法，详细复杂的查询方法请参阅官方文档，这里不再举例阐述### 编程要求现在请按照上述要求，实现下面步骤:(你需要修改的文件均在`step/step10/stu`目录下，请勿修改其余目录文件)1. 创建对应的sql语句: `step/step10/stu/user.sql`   - 创建数据库:`user`   - 创建数据表:`user` -> 包含要求如下     - id: 主键，自增     - user_name: varchar(255)     - passwd: varchar(255)2. 链接到控制台执行sql语句,已给出命令，请直接执行:`mysql -uroot -p123123 -h127.0.0.1 -P3306   < /data/workspace/myshixun/step/step10/stu/user.sql`3. 编写修改`step/step10/stu/gen/gen.go`文件，实现生成相对应的桩代码4. 修改`step/step10/stu/main.go`文件，链接到数据库，并查询用户名称为`bigwhite`的用户，之后按照下方的模板输出### 测试说明1. 平台会插入一个用户数据到，你所创建的数据库中,例如`user_name=bigwhite,passwd=abcd`2. 平台会执行你的`main`(`step/step10/stu/main.go`)程序，判断程序输出的用户`bigwhite`的信息是否一致，一致则通过测试，不一致则不通过用例:```text插入: user_name=bigwhite,passwd=abcd预期值: user name:bigwhite,passwd:abcd```